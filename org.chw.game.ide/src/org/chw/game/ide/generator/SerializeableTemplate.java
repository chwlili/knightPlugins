package org.chw.game.ide.generator;

public class SerializeableTemplate
{
	public static String getContent(String packName,String typeName)
	{
		StringBuilder stream=new StringBuilder();
		
		stream.append("package "+packName+"\n");
		stream.append("{\n");
		stream.append("\timport flash.display.BitmapData;\n");
		stream.append("\timport flash.geom.Rectangle;\n");
		stream.append("\timport flash.utils.ByteArray;\n");
		stream.append("\timport flash.utils.Endian;\n");
		stream.append("\timport flash.utils.IDataInput;\n");
		stream.append("\timport flash.utils.IDataOutput;\n");
		stream.append("\t\n");
		stream.append("\tpublic class "+typeName+"\n");
		stream.append("\t{\n");
		stream.append("\t\t//\n");
		stream.append("\t\tprivate const VARINT:int=0;\n");
		stream.append("\t\tprivate const FIXED64:int=1;\n");
		stream.append("\t\tprivate const BYTES:int=2;\n");
		stream.append("\t\tprivate const START_GROUP:int=3;\n");
		stream.append("\t\tprivate const END_GROUP:int=4;\n");
		stream.append("\t\tprivate const FIXED32:int=5;\n");
		stream.append("\t\tprivate const zlibBitmap:Boolean=true;\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\tprotected var _tags:Array=[];\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 从字节流反序列化 \n");
		stream.append("\t\t * @param input\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function deserialize(input:ByteArray,endPos:int=int.MAX_VALUE):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 序列化 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function serialize(output:IDataOutput):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 转换为字节数组\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function toByteArray():ByteArray\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar bytes:ByteArray=new ByteArray();\n");
		stream.append("\t\t\tvar tmp:ByteArray;\n");
		stream.append("\t\t\tvar swap:ByteArray=new ByteArray();\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tserialize(bytes);\n");
		stream.append("\t\t\tbytes.position=0;\t\t\t\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\twhile(_tags.length>0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tvar last:int=_tags.pop();\n");
		stream.append("\t\t\t\twriteRawVarint32To(swap,makeTag(last,2));\n");
		stream.append("\t\t\t\twriteRawVarint32To(swap,bytes.length);\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\t\t\tbytes.position=0;\n");
		stream.append("\t\t\t\twriteRawBytesTo(swap,bytes);\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\t\t\tbytes.length=0;\n");
		stream.append("\t\t\t\ttmp=bytes;\n");
		stream.append("\t\t\t\tbytes=swap;\n");
		stream.append("\t\t\t\tswap=tmp;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\treturn bytes;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 跳过字段 \n");
		stream.append("\t\t * @param tag\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function skipFieldFrom(input:IDataInput,tag:int):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar mask:int=(1<<3)-1;\n");
		stream.append("\t\t\tvar type:int=tag & mask;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tswitch(type)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tcase VARINT:\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\t//varint\n");
		stream.append("\t\t\t\t\tfor(var i:int=0;i<10;i++)\n");
		stream.append("\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\tif(readRawByteFrom(input)>=0)\n");
		stream.append("\t\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\t\treturn;\n");
		stream.append("\t\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\tcase FIXED64:\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\t//64-bit\n");
		stream.append("\t\t\t\t\treadRawLittleEndian64From(input);\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\tcase BYTES:\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\t//定长\n");
		stream.append("\t\t\t\t\treadRawBytesFrom(input,readRawVarint32From(input));\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\tcase START_GROUP:\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\t//start group\n");
		stream.append("\t\t\t\t\tthrow new Error(\"未实现start group\");\n");
		stream.append("\t\t\t\t\t/*\n");
		stream.append("\t\t\t\t\tvar innerTag:int;\n");
		stream.append("\t\t\t\t\twhile(true)\n");
		stream.append("\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\tinnerTag=readTagFrom(input);\n");
		stream.append("\t\t\t\t\tif(innerTag==0 || skipFieldFrom(input,innerTag)==false)\n");
		stream.append("\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\tif(innerTag!=WireFormat.makeTag(WireFormat.getTagFieldNumber(tag),WireFormat.WIRETYPE_END_GROUP))\n");
		stream.append("\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\tthrow new Error(\"END-GROUP TAG 未找到！\");\n");
		stream.append("\t\t\t\t\t}*/\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\tcase END_GROUP:\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\t//end group\n");
		stream.append("\t\t\t\t\tthrow new Error(\"未实现end group\");\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\tcase FIXED32:\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\t//32-bit\n");
		stream.append("\t\t\t\t\treadRawLittleEndian32From(input);\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 获取字段的序号 \n");
		stream.append("\t\t * @param tag\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function getFieldNum(tag:int):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn tag>>3;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t//\n");
		stream.append("\t\t// 基本数据类型的读取\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * ZigZag32解码 \n");
		stream.append("\t\t * @param n\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function decodeZigZag32(n:uint):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn (n>>>1) ^ -(n & 1);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * ZigZag64解码 \n");
		stream.append("\t\t * @param n\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\t/*protected function decodeZigZag64(n:BigInteger):BigInteger\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar nA:BigInteger=n.shiftRight(1);\n");
		stream.append("\t\t\tvar nB:BigInteger=n.and(BigInteger.ONE);\n");
		stream.append("\t\t\treturn nA.xor(nB);\n");
		stream.append("\t\t}*/\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个Tag \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readTagFrom(input:IDataInput):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tif(input.bytesAvailable!=0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\treturn readRawVarint32From(input);\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\telse\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\treturn 0;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个字节 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readRawByteFrom(input:IDataInput):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn input.readByte();\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个32位的Varint \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readRawVarint32From(input:IDataInput):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar tmp:int=readRawByteFrom(input);\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tif(tmp>=0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\treturn tmp;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvar result:int=tmp & 0x7F;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tif((tmp=readRawByteFrom(input))>=0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tresult |= tmp<<7;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\telse\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tresult |= ( tmp & 0x7F )<<7;\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\t\t\tif((tmp=readRawByteFrom(input))>=0)\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\tresult |= tmp<<14;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\telse\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\tresult |= (tmp & 0x7F )<<14;\n");
		stream.append("\t\t\t\t\t\n");
		stream.append("\t\t\t\t\tif((tmp=readRawByteFrom(input))>=0)\n");
		stream.append("\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\tresult |= tmp<<21;\n");
		stream.append("\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\telse\n");
		stream.append("\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\tresult |= (tmp&0x7F)<<21;\n");
		stream.append("\t\t\t\t\t\t\n");
		stream.append("\t\t\t\t\t\tif((tmp=readRawByteFrom(input))>=0)\n");
		stream.append("\t\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\t\tresult |= tmp<<28;\n");
		stream.append("\t\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\t\telse\n");
		stream.append("\t\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\t\tresult |= (tmp&0xfF)<<28;\n");
		stream.append("\t\t\t\t\t\t\t\n");
		stream.append("\t\t\t\t\t\t\tfor(var i:int=0;i<5;i++)\n");
		stream.append("\t\t\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\t\t\tif(readRawByteFrom(input)>=0)\n");
		stream.append("\t\t\t\t\t\t\t\t{\n");
		stream.append("\t\t\t\t\t\t\t\t\treturn result;\n");
		stream.append("\t\t\t\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\t\t\tthrow new Error(\"读取Varint32时遇到无效的Varint！\");\n");
		stream.append("\t\t\t\t\t\t}\n");
		stream.append("\t\t\t\t\t}\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\treturn result;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个64位的Varint \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function readRawVarint64From(input:IDataInput):String\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar key:String=\"\";\n");
		stream.append("\t\t\tvar step:int=0;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\twhile(step<10)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tvar byte:uint=input.readUnsignedByte();\n");
		stream.append("\t\t\t\tvar byteChar:String=(byte & 0x7F).toString(2);\n");
		stream.append("\t\t\t\twhile(byteChar.length<7)\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\tbyteChar=\"0\"+byteChar;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\tkey=byteChar+key;\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\t\t\tif((byte & 0x80)==0)\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\tbreak;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\t\t\tstep++;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvar id:String=\"\";\n");
		stream.append("\t\t\tif(key.length>=32)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tid=parseInt(key.substr(key.length-32),2).toString(16);\n");
		stream.append("\t\t\t\twhile(id.length<8)\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\tid=\"0\"+id;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\tif(key.length>32)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tid=parseInt(key.substr(0,key.length-32),2).toString(16)+id;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\tif(id.length%2!=0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tid=\"0\"+id;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\treturn id;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个32位的浮点数 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readRawLittleEndian32From(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar endian:String=input.endian;\n");
		stream.append("\t\t\tinput.endian=Endian.LITTLE_ENDIAN;\n");
		stream.append("\t\t\tvar result:Number=input.readFloat();\n");
		stream.append("\t\t\tinput.endian=endian;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\treturn result;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个64位的浮点数 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readRawLittleEndian64From(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar endian:String=input.endian;\n");
		stream.append("\t\t\tinput.endian=Endian.LITTLE_ENDIAN;\n");
		stream.append("\t\t\tvar result:Number=input.readDouble();\n");
		stream.append("\t\t\tinput.endian=endian;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\treturn result;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个字节流 \n");
		stream.append("\t\t * @param size\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readRawBytesFrom(input:IDataInput,size:uint):ByteArray\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar bytes:ByteArray=new ByteArray();\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tif(size!=0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tinput.readBytes(bytes,0,size);\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\treturn bytes;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t//------------------------------------------------------------------------------------------------------\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//  反序列化读取\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//-------------------------------------------------------------------------------------------------------\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个32位的int \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readInt32From(input:IDataInput):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawVarint32From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个32位的无符号int \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readUInt32From(input:IDataInput):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawVarint32From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个32位的有符号int \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readSInt32From(input:IDataInput):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn decodeZigZag32(readRawVarint32From(input));\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个64位的int \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readInt64From(input:IDataInput):String\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawVarint64From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个64位的无符号int \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readUInt64From(input:IDataInput):String\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawVarint64From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个64位的有符号int \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readSInt64From(input:IDataInput):String\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\t//return decodeZigZag64(readRawVarint64From(input));\n");
		stream.append("\t\t\treturn readRawVarint64From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个32位的浮点数\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readFloatFrom(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawLittleEndian32From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个Fixed32数值\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readFixed32From(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawLittleEndian32From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个SFixed32数值 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readSFixed32From(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawLittleEndian32From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个64位的浮点数 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readDoubleFrom(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawLittleEndian64From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个Fixed64数值 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readFixed64From(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawLittleEndian64From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个SFixed64数值 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readSFixed64From(input:IDataInput):Number\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawLittleEndian64From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个布尔值 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readBoolFrom(input:IDataInput):Boolean\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawVarint32From(input) !=0;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个枚举值 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readEnumFrom(input:IDataInput):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawVarint32From(input);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个字符串 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readStringFrom(input:IDataInput):String\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn input.readUTFBytes(readRawVarint32From(input));\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个字节流 \n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readBytesFrom(input:IDataInput):ByteArray\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn readRawBytesFrom(input,readRawVarint32From(input));\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 读取一个位图 \n");
		stream.append("\t\t * @param input\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function readBitmapFrom(input:IDataInput):BitmapData\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar bytes:ByteArray=readRawBytesFrom(input,readRawVarint32From(input));\n");
		stream.append("\t\t\tbytes.position=0;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvar w:uint=bytes.readUnsignedInt();\n");
		stream.append("\t\t\tvar h:uint=bytes.readUnsignedInt();\n");
		stream.append("\t\t\tvar zlibed:Boolean=bytes.readBoolean();\n");
		stream.append("\t\t\tvar datas:ByteArray=new ByteArray();\n");
		stream.append("\t\t\tbytes.readBytes(datas);\n");
		stream.append("\t\t\tif(zlibed)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tdatas.uncompress();\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tdatas.position=0;\n");
		stream.append("\t\t\tvar bitmap:BitmapData=new BitmapData(w,h,true,0xff000000);\n");
		stream.append("\t\t\tbitmap.setPixels(new Rectangle(0,0,w,h),datas);\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\treturn bitmap;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t//----------------------------------------------------------------------------------------------------------------------------\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//  序列化\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//----------------------------------------------------------------------------------------------------------------------------\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t//\n");
		stream.append("\t\t// 静态函数\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 对一个32位int值进行ZigZag编码 \n");
		stream.append("\t\t * @param n\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function encodeZigZag32(n:int):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn (n<<1)^(n>>31);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 对一个64位int值进行ZigZag编码 \n");
		stream.append("\t\t * @param n\n");
		stream.append("\t\t * @return \n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\t/*protected function encodeZigZag64(n:BigInteger):BigInteger\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar nA:BigInteger=n.shiftLeft(1);\n");
		stream.append("\t\t\tvar nB:BigInteger=n.shiftRight(63);\n");
		stream.append("\t\t\treturn nA.xor(nB);\n");
		stream.append("\t\t}*/\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 生成一个Tag \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param wireType\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tprotected function makeTag(fieldNumber:int,wireType:int):int\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\treturn (fieldNumber<<3)|wireType;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t//\n");
		stream.append("\t\t// 基本数据类型的写入\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个字节 \n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeRawByteTo(output:IDataOutput,value:int):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\toutput.writeByte(value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个字节数组 \n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * @param offset\n");
		stream.append("\t\t * @param length\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeRawBytesTo(output:IDataOutput,value:ByteArray):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\toutput.writeBytes(value,0,value.length);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个字节数组的部分字节 \n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * @param offset\n");
		stream.append("\t\t * @param length\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeRawBytesPartialTo(output:IDataOutput,value:ByteArray,offset:uint=0,length:uint=0):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\toutput.writeBytes(value,offset,length);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个TAG \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param wireType\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeTagTo(output:IDataOutput,fieldNumber:int,wireType:int):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteRawVarint32To(output,makeTag(fieldNumber,wireType));\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个32位的Varint \n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeRawVarint32To(output:IDataOutput,value:int):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twhile(true)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tif((value & ~0x7F)==0)\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\twriteRawByteTo(output,value);\n");
		stream.append("\t\t\t\t\treturn;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\telse\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\twriteRawByteTo(output,(value & 0x7F)|0x80);\n");
		stream.append("\t\t\t\t\tvalue>>>=7;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个64位的Varint \n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeRawVarint64To(output:IDataOutput,value:String):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tif(value.length%2!=0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tvalue=\"0\"+value;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvar i:int=0;\n");
		stream.append("\t\t\tvar bits:String=\"\";\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\twhile(i<value.length)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tvar byte:uint=parseInt(value.substr(i,2),16);\n");
		stream.append("\t\t\t\tvar byteBits:String=byte.toString(2);;\n");
		stream.append("\t\t\t\twhile(byteBits.length<8)\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\tbyteBits=\"0\"+byteBits;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\tbits+=byteBits;\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\t\t\ti++;\n");
		stream.append("\t\t\t\ti++;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvar index:int=bits.indexOf(\"1\");\n");
		stream.append("\t\t\tif(index!=-1)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tbits=bits.substr(index);\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvar r:int=bits.length;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\twhile(r>0)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tvar left:int=Math.max(0,r-7);\n");
		stream.append("\t\t\t\tvar right:int=r;\n");
		stream.append("\t\t\t\t\n");
		stream.append("\t\t\t\tvar val:uint=parseInt(bits.substring(left,right),2);\n");
		stream.append("\t\t\t\tif(r>7)\n");
		stream.append("\t\t\t\t{\n");
		stream.append("\t\t\t\t\tval|=0x80;\n");
		stream.append("\t\t\t\t}\n");
		stream.append("\t\t\t\twriteRawByteTo(output,val);\n");
		stream.append("\t\t\t\tr-=7;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 以低位在前的方式写入一个32位浮点数 \n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeRawLittleEndian32To(output:IDataOutput,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar endian:String=output.endian;\n");
		stream.append("\t\t\toutput.endian=Endian.LITTLE_ENDIAN;\n");
		stream.append("\t\t\toutput.writeFloat(value);\n");
		stream.append("\t\t\toutput.endian=endian;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 以低位在前的方式写入一个64位浮点数 \n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeRawLittleEndian64To(output:IDataOutput,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar endian:String=output.endian;\n");
		stream.append("\t\t\toutput.endian=Endian.LITTLE_ENDIAN;\n");
		stream.append("\t\t\toutput.writeDouble(value);\n");
		stream.append("\t\t\toutput.endian=endian;\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t//\n");
		stream.append("\t\t// protobuf数据类型的写入\n");
		stream.append("\t\t//\n");
		stream.append("\t\t//-------------------------------------------------------------------------\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个布尔值 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeBoolTo(output:IDataOutput,fieldNumber:int,value:Boolean):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\twriteRawByteTo(output,value ? 1 : 0 );\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个枚举值 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeEnumTo(output:IDataOutput,fieldNumber:int,value:int):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\twriteRawVarint32To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个定长字符串 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeStringTo(output:IDataOutput,fieldNumber:int,value:String):void\n");
		stream.append("\t\t{\t\n");
		stream.append("\t\t\tvar bytes:ByteArray=new ByteArray();\n");
		stream.append("\t\t\tbytes.writeUTFBytes(value);\n");
		stream.append("\t\t\tbytes.position=0;\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,BYTES);\t\n");
		stream.append("\t\t\twriteRawVarint32To(output,bytes.length);\n");
		stream.append("\t\t\twriteRawBytesTo(output,bytes);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个写长字节数组 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeBytesTo(output:IDataOutput,fieldNumber:int,value:ByteArray):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,BYTES);\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvalue.position=0;\n");
		stream.append("\t\t\twriteRawVarint32To(output,value.length);\n");
		stream.append("\t\t\twriteRawBytesTo(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个位图的数据 \n");
		stream.append("\t\t * @param output\n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeBitmapTo(output:IDataOutput,fieldNumber:int,value:BitmapData):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar bytes:ByteArray=new ByteArray();\n");
		stream.append("\t\t\tbytes.writeUnsignedInt(value.width);\n");
		stream.append("\t\t\tbytes.writeUnsignedInt(value.height);\n");
		stream.append("\t\t\tbytes.writeBoolean(zlibBitmap);\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tvar datas:ByteArray=value.getPixels(value.rect);\n");
		stream.append("\t\t\tif(zlibBitmap)\n");
		stream.append("\t\t\t{\n");
		stream.append("\t\t\t\tdatas.compress();\n");
		stream.append("\t\t\t\tdatas.position=0;\n");
		stream.append("\t\t\t}\n");
		stream.append("\t\t\tbytes.writeBytes(datas);\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,BYTES);\n");
		stream.append("\t\t\tbytes.position=0;\n");
		stream.append("\t\t\twriteRawVarint32To(output,bytes.length);\n");
		stream.append("\t\t\twriteRawBytesTo(output,bytes);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个子消息 \n");
		stream.append("\t\t * @param output\n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeMessageTo(output:IDataOutput,fieldNumber:int,value:SerializeableData):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\tvar bytes:ByteArray=new ByteArray();\n");
		stream.append("\t\t\tvalue.serialize(bytes);\n");
		stream.append("\t\t\t\n");
		stream.append("\t\t\tbytes.position=0;\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,BYTES);\n");
		stream.append("\t\t\twriteRawVarint32To(output,bytes.length);\n");
		stream.append("\t\t\twriteRawBytesTo(output,bytes);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个32位int \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeInt32To(output:IDataOutput,fieldNumber:int,value:int):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\twriteRawVarint32To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个无符号的32位int \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeUInt32To(output:IDataOutput,fieldNumber:int,value:uint):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\twriteRawVarint32To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个有符号的32位int \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeSInt32To(output:IDataOutput,fieldNumber:int,value:int):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\twriteRawVarint32To(output,encodeZigZag32(value));\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个64位int \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeInt64To(output:IDataOutput,fieldNumber:int,value:String):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\twriteRawVarint64To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个无符号的64位int \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeUInt64To(output:IDataOutput,fieldNumber:int,value:String):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\twriteRawVarint64To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个有符号的64位int \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeSInt64To(output:IDataOutput,fieldNumber:int,value:String):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,VARINT);\n");
		stream.append("\t\t\t//writeRawVarint64To(output,encodeZigZag64(value));\n");
		stream.append("\t\t\twriteRawVarint64To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个32位浮点数 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeFloatTo(output:IDataOutput,fieldNumber:int,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,FIXED32);\n");
		stream.append("\t\t\twriteRawLittleEndian32To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个Fixed32数 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeFixed32To(output:IDataOutput,fieldNumber:int,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,FIXED32);\n");
		stream.append("\t\t\twriteRawLittleEndian32To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个SFixed32数 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeSFixed32To(output:IDataOutput,fieldNumber:int,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,FIXED32);\n");
		stream.append("\t\t\twriteRawLittleEndian32To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个64位浮点数 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param vlaue\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeDoubleTo(output:IDataOutput,fieldNumber:int,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,FIXED64);\n");
		stream.append("\t\t\twriteRawLittleEndian64To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个Fixed64数 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeFixed64To(output:IDataOutput,fieldNumber:int,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,FIXED64);\n");
		stream.append("\t\t\twriteRawLittleEndian64To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t\t\n");
		stream.append("\t\t/**\n");
		stream.append("\t\t * 写入一个SFixed64数 \n");
		stream.append("\t\t * @param fieldNumber\n");
		stream.append("\t\t * @param value\n");
		stream.append("\t\t * \n");
		stream.append("\t\t */\t\t\n");
		stream.append("\t\tpublic function writeSFixed64To(output:IDataOutput,fieldNumber:int,value:Number):void\n");
		stream.append("\t\t{\n");
		stream.append("\t\t\twriteTagTo(output,fieldNumber,FIXED64);\n");
		stream.append("\t\t\twriteRawLittleEndian64To(output,value);\n");
		stream.append("\t\t}\n");
		stream.append("\t}\n");
		stream.append("}\n");
		
		return stream.toString();
	}
}
